//////////////////////////////////////////////////////////////////////////////
// NOTICE:
//
// ADLib, Prop and their related set of tools and documentation are in the
// public domain.   The author(s) of this software reserve no copyrights on
// the source code and any code generated using the tools.  You are encouraged
// to use ADLib and Prop to develop software, in both academic and commercial
// settings, and are free to incorporate any part of ADLib and Prop into
// your programs.
//
// Although you are under no obligation to do so, we strongly recommend that
// you give away all software developed using our tools.
//
// We also ask that credit be given to us when ADLib and/or Prop are used in
// your programs, and that this notice be preserved intact in all the source
// code.
//
// This software is still under development and we welcome any suggestions
// and help from the users.
//
// Allen Leung
// 1994
//////////////////////////////////////////////////////////////////////////////

#ifndef binomial_queue_h
#define binomial_queue_h

#include <AD/trees/trees.h>

//////////////////////////////////////////////////////////////////////////
//  Class BinomialQueue.  Binomial queues are due to Vuillemin.
//////////////////////////////////////////////////////////////////////////

template <class K, class V>
class BinomialQueue
{
  int count;

  /////////////////////////////////////////////////////////////////////
  // Constructors and destructor
  /////////////////////////////////////////////////////////////////////

public:
  BinomialQueue();
  ~BinomialQueue();

  /////////////////////////////////////////////////////////////////////
  // Selectors
  /////////////////////////////////////////////////////////////////////
  inline int  size()     const
  {
    return count;
  }
  inline int  capacity() const
  {
    return count;
  }
  inline Bool is_empty() const
  {
    return count == 0;
  }
  inline Bool is_full()  const
  {
    return false;
  }
  Ix min() const;

  /////////////////////////////////////////////////////////////////////
  // Mutators
  /////////////////////////////////////////////////////////////////////
  Ix   insert(const K&, const V&);
  Bool delete_min();

  /////////////////////////////////////////////////////////////////////
  // Iterators
  /////////////////////////////////////////////////////////////////////
  const K& key(Ix)   const;
  const V& value(Ix) const;
  V&       value(Ix);
};

///////////////////////////////////////////////////////////////////////////
// Implementation of the template methods
///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
//  Find the least element
///////////////////////////////////////////////////////////////////////////

template <class K, class V>
Ix BinomialQueue<K,V>::min() const
  {}

///////////////////////////////////////////////////////////////////////////
//  Insert new elements
///////////////////////////////////////////////////////////////////////////

template <class K, class V>
Ix BinomialQueue<K,V>::insert(const K&, const V&)
{}

///////////////////////////////////////////////////////////////////////////
//  Remove the minimal element
///////////////////////////////////////////////////////////////////////////

template <class K, class V>
Bool BinomialQueue<K,V>::delete_min()
{}

#endif
