///////////////////////////////////////////////////////////////////////////////
//  This file is generated automatically using Prop (version 2.3.5),
//  last updated on Jun 18, 1997.
//  The original source file is "willard-ast.ph".
///////////////////////////////////////////////////////////////////////////////

#define PROP_REWRITING_USED
#define PROP_STRCMP_USED
#define PROP_QUARK_USED
#include <propdefs.h>
#line 1 "willard-ast.ph"
#ifndef willard_ast_h 
#define willard_ast_h

#include <AD/generic/generic.h>
class PrettyOStream;


struct ConsCounter { static int count; ConsCounter() { count++; } };

#line 10 "willard-ast.ph"
#line 10 "willard-ast.ph"
///////////////////////////////////////////////////////////////////////////////
//
// Forward class definition for List<T>
//
///////////////////////////////////////////////////////////////////////////////
#ifndef datatype_List_defined
#define datatype_List_defined
template <class T> class a_List;
#define List(T) a_List<T> *
#endif

#  define nil_1_ 0

///////////////////////////////////////////////////////////////////////////////
//
// Class for datatype constructor List<T>::#[...]
//
///////////////////////////////////////////////////////////////////////////////
template <class T> class a_List : public ConsCounter {
public:
#line 10 "willard-ast.ph"
   T _1; a_List<T> *  _2; 
   a_List (T x_1, a_List<T> *  x_2);
   a_List (T x_1);
};
template <class T> inline int boxed(const a_List<T> * x) { return x != 0; }
template <class T> inline int untag(const a_List<T> * x) { return x ? 1 : 0; }
///////////////////////////////////////////////////////////////////////////////
//
// Datatype constructor functions for List<T>
//
///////////////////////////////////////////////////////////////////////////////
template <class T> extern a_List<T> * list_1_ (T x_1, a_List<T> *  x_2);
template <class T> extern a_List<T> * list_1_ (T x_1);
///////////////////////////////////////////////////////////////////////////////
//
// Downcasting functions for List<T>
//
///////////////////////////////////////////////////////////////////////////////


#line 10 "willard-ast.ph"
#line 10 "willard-ast.ph"

#line 11 "willard-ast.ph"
#line 11 "willard-ast.ph"
#line 11 "willard-ast.ph"
#line 11 "willard-ast.ph"


//
//  This is the abstract syntax of the query language
//
#line 16 "willard-ast.ph"
#line 52 "willard-ast.ph"
///////////////////////////////////////////////////////////////////////////////
//
// Forward class definition for Literal
//
///////////////////////////////////////////////////////////////////////////////
#ifndef datatype_Literal_defined
#define datatype_Literal_defined
   class a_Literal;
   typedef a_Literal * Literal;
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Forward class definition for Exp
//
///////////////////////////////////////////////////////////////////////////////
#ifndef datatype_Exp_defined
#define datatype_Exp_defined
   class a_Exp;
   typedef a_Exp * Exp;
#endif

///////////////////////////////////////////////////////////////////////////////
// Definition of type Id
///////////////////////////////////////////////////////////////////////////////
#line 49 "willard-ast.ph"
typedef char const * Id;

///////////////////////////////////////////////////////////////////////////////
// Definition of type Ids
///////////////////////////////////////////////////////////////////////////////
#line 50 "willard-ast.ph"
typedef a_List<Id> *  Ids;

///////////////////////////////////////////////////////////////////////////////
// Definition of type Exps
///////////////////////////////////////////////////////////////////////////////
#line 51 "willard-ast.ph"
typedef a_List<Exp> *  Exps;

///////////////////////////////////////////////////////////////////////////////
//
// Base class for datatype Literal
//
///////////////////////////////////////////////////////////////////////////////
class a_Literal : public ConsCounter {
public:
   enum Tag_Literal {
      tag_INT = 0, tag_STRING = 1, tag_BOOL = 2
   };

public:
   const Tag_Literal tag__; // variant tag
protected:
   inline a_Literal(Tag_Literal t__) : tag__(t__) {}
public:
};
inline int boxed(const a_Literal *) { return 1; }
inline int untag(const a_Literal * x) { return x->tag__; }
///////////////////////////////////////////////////////////////////////////////
//
// Class for datatype constructor Literal::INT
//
///////////////////////////////////////////////////////////////////////////////
class Literal_INT : public a_Literal {
public:
#line 16 "willard-ast.ph"
   int INT; 
   Literal_INT (int x_INT);
};

///////////////////////////////////////////////////////////////////////////////
//
// Class for datatype constructor Literal::STRING
//
///////////////////////////////////////////////////////////////////////////////
class Literal_STRING : public a_Literal {
public:
#line 17 "willard-ast.ph"
   char const * STRING; 
   Literal_STRING (char const * x_STRING);
};

///////////////////////////////////////////////////////////////////////////////
//
// Class for datatype constructor Literal::BOOL
//
///////////////////////////////////////////////////////////////////////////////
class Literal_BOOL : public a_Literal {
public:
#line 18 "willard-ast.ph"
   Bool BOOL; 
   Literal_BOOL (Bool x_BOOL);
};

///////////////////////////////////////////////////////////////////////////////
//
// Datatype constructor functions for Literal
//
///////////////////////////////////////////////////////////////////////////////
extern a_Literal * INT (int x_INT);
extern a_Literal * STRING (char const * x_STRING);
extern a_Literal * BOOL (Bool x_BOOL);
///////////////////////////////////////////////////////////////////////////////
//
// Downcasting functions for Literal
//
///////////////////////////////////////////////////////////////////////////////
inline Literal_INT * _INT(const a_Literal * _x_) { return (Literal_INT *)_x_; }
inline Literal_STRING * _STRING(const a_Literal * _x_) { return (Literal_STRING *)_x_; }
inline Literal_BOOL * _BOOL(const a_Literal * _x_) { return (Literal_BOOL *)_x_; }

///////////////////////////////////////////////////////////////////////////////
//
// Base class for datatype Exp
//
///////////////////////////////////////////////////////////////////////////////
class a_Exp : public ConsCounter, public TermObj {
public:
   enum Tag_Exp {
      tag_OP = 0, tag_APP = 1, tag_LIT = 2, 
      tag_ID = 3, tag_TUPLE = 4, tag_FORALL = 5, 
      tag_EXISTS = 6, tag_GUARD = 7, tag_GENERATOR = 8, 
      tag_LET = 9
   };

public:
   const Tag_Exp tag__; // variant tag
protected:
   inline a_Exp(Tag_Exp t__) : tag__(t__) {}
public:
};
inline int boxed(const a_Exp *) { return 1; }
inline int untag(const a_Exp * x) { return x->tag__; }
///////////////////////////////////////////////////////////////////////////////
//
// Class for datatype constructor Exp::OP
//
///////////////////////////////////////////////////////////////////////////////
class Exp_OP : public a_Exp {
public:
#line 20 "willard-ast.ph"
   Id _1; Exps _2; 
   Exp_OP (Id x_1, Exps x_2);
};

///////////////////////////////////////////////////////////////////////////////
//
// Class for datatype constructor Exp::APP
//
///////////////////////////////////////////////////////////////////////////////
class Exp_APP : public a_Exp {
public:
#line 21 "willard-ast.ph"
   Id _1; Exps _2; 
   Exp_APP (Id x_1, Exps x_2);
};

///////////////////////////////////////////////////////////////////////////////
//
// Class for datatype constructor Exp::LIT
//
///////////////////////////////////////////////////////////////////////////////
class Exp_LIT : public a_Exp {
public:
#line 22 "willard-ast.ph"
   Literal LIT; 
   Exp_LIT (Literal x_LIT);
};

///////////////////////////////////////////////////////////////////////////////
//
// Class for datatype constructor Exp::ID
//
///////////////////////////////////////////////////////////////////////////////
class Exp_ID : public a_Exp {
public:
#line 23 "willard-ast.ph"
   Id ID; 
   Exp_ID (Id x_ID);
};

///////////////////////////////////////////////////////////////////////////////
//
// Class for datatype constructor Exp::TUPLE
//
///////////////////////////////////////////////////////////////////////////////
class Exp_TUPLE : public a_Exp {
public:
#line 24 "willard-ast.ph"
   Exps TUPLE; 
   Exp_TUPLE (Exps x_TUPLE);
};

///////////////////////////////////////////////////////////////////////////////
//
// Class for datatype constructor Exp::FORALL
//
///////////////////////////////////////////////////////////////////////////////
class Exp_FORALL : public a_Exp {
public:
#line 25 "willard-ast.ph"
   Id _1; Exp _2; Exp _3; 
   Exp_FORALL (Id x_1, Exp x_2, Exp x_3);
};

///////////////////////////////////////////////////////////////////////////////
//
// Class for datatype constructor Exp::EXISTS
//
///////////////////////////////////////////////////////////////////////////////
class Exp_EXISTS : public a_Exp {
public:
#line 26 "willard-ast.ph"
   Id _1; Exp _2; Exp _3; 
   Exp_EXISTS (Id x_1, Exp x_2, Exp x_3);
};

///////////////////////////////////////////////////////////////////////////////
//
// Class for datatype constructor Exp::GUARD
//
///////////////////////////////////////////////////////////////////////////////
class Exp_GUARD : public a_Exp {
public:
#line 27 "willard-ast.ph"
   Exp _1; Exp _2; 
   Exp_GUARD (Exp x_1, Exp x_2);
};

///////////////////////////////////////////////////////////////////////////////
//
// Class for datatype constructor Exp::GENERATOR
//
///////////////////////////////////////////////////////////////////////////////
class Exp_GENERATOR : public a_Exp {
public:
#line 28 "willard-ast.ph"
   Ids _1; Exps _2; Exp _3; 
   Exp_GENERATOR (Ids x_1, Exps x_2, Exp x_3);
};

///////////////////////////////////////////////////////////////////////////////
//
// Class for datatype constructor Exp::LET
//
///////////////////////////////////////////////////////////////////////////////
class Exp_LET : public a_Exp {
public:
#line 29 "willard-ast.ph"
   Id _1; Exp _2; Exp _3; 
   Exp_LET (Id x_1, Exp x_2, Exp x_3);
};

///////////////////////////////////////////////////////////////////////////////
//
// Datatype constructor functions for Exp
//
///////////////////////////////////////////////////////////////////////////////
extern a_Exp * OP (Id x_1, Exps x_2);
extern a_Exp * APP (Id x_1, Exps x_2);
extern a_Exp * LIT (Literal x_LIT);
extern a_Exp * ID (Id x_ID);
extern a_Exp * TUPLE (Exps x_TUPLE);
extern a_Exp * FORALL (Id x_1, Exp x_2, Exp x_3);
extern a_Exp * EXISTS (Id x_1, Exp x_2, Exp x_3);
extern a_Exp * GUARD (Exp x_1, Exp x_2);
extern a_Exp * GENERATOR (Ids x_1, Exps x_2, Exp x_3);
extern a_Exp * LET (Id x_1, Exp x_2, Exp x_3);
///////////////////////////////////////////////////////////////////////////////
//
// Downcasting functions for Exp
//
///////////////////////////////////////////////////////////////////////////////
inline Exp_OP * _OP(const a_Exp * _x_) { return (Exp_OP *)_x_; }
inline Exp_APP * _APP(const a_Exp * _x_) { return (Exp_APP *)_x_; }
inline Exp_LIT * _LIT(const a_Exp * _x_) { return (Exp_LIT *)_x_; }
inline Exp_ID * _ID(const a_Exp * _x_) { return (Exp_ID *)_x_; }
inline Exp_TUPLE * _TUPLE(const a_Exp * _x_) { return (Exp_TUPLE *)_x_; }
inline Exp_FORALL * _FORALL(const a_Exp * _x_) { return (Exp_FORALL *)_x_; }
inline Exp_EXISTS * _EXISTS(const a_Exp * _x_) { return (Exp_EXISTS *)_x_; }
inline Exp_GUARD * _GUARD(const a_Exp * _x_) { return (Exp_GUARD *)_x_; }
inline Exp_GENERATOR * _GENERATOR(const a_Exp * _x_) { return (Exp_GENERATOR *)_x_; }
inline Exp_LET * _LET(const a_Exp * _x_) { return (Exp_LET *)_x_; }

///////////////////////////////////////////////////////////////////////////////
// Definition of law Int
///////////////////////////////////////////////////////////////////////////////
#line 31 "willard-ast.ph"
inline Exp Int(int i)
{ return LIT(INT(i)); }

///////////////////////////////////////////////////////////////////////////////
// Definition of law Boolean
///////////////////////////////////////////////////////////////////////////////
#line 32 "willard-ast.ph"
inline Exp Boolean(Bool b)
{ return LIT(BOOL(b)); }

///////////////////////////////////////////////////////////////////////////////
// Definition of law And
///////////////////////////////////////////////////////////////////////////////
#line 35 "willard-ast.ph"
inline Exp And(Exp a, Exp b)
{ return OP("and",list_1_(a,list_1_(b))); }

///////////////////////////////////////////////////////////////////////////////
// Definition of law Or
///////////////////////////////////////////////////////////////////////////////
#line 36 "willard-ast.ph"
inline Exp Or(Exp a, Exp b)
{ return OP("or",list_1_(a,list_1_(b))); }

///////////////////////////////////////////////////////////////////////////////
// Definition of law Not
///////////////////////////////////////////////////////////////////////////////
#line 37 "willard-ast.ph"
inline Exp Not(Exp a)
{ return OP("not",list_1_(a)); }

///////////////////////////////////////////////////////////////////////////////
// Definition of law Eq
///////////////////////////////////////////////////////////////////////////////
#line 38 "willard-ast.ph"
inline Exp Eq(Exp a, Exp b)
{ return OP("=",list_1_(a,list_1_(b))); }

///////////////////////////////////////////////////////////////////////////////
// Definition of law Ne
///////////////////////////////////////////////////////////////////////////////
#line 39 "willard-ast.ph"
inline Exp Ne(Exp a, Exp b)
{ return OP("/=",list_1_(a,list_1_(b))); }

///////////////////////////////////////////////////////////////////////////////
// Definition of law Gt
///////////////////////////////////////////////////////////////////////////////
#line 40 "willard-ast.ph"
inline Exp Gt(Exp a, Exp b)
{ return OP(">",list_1_(a,list_1_(b))); }

///////////////////////////////////////////////////////////////////////////////
// Definition of law Ge
///////////////////////////////////////////////////////////////////////////////
#line 41 "willard-ast.ph"
inline Exp Ge(Exp a, Exp b)
{ return OP(">=",list_1_(a,list_1_(b))); }

///////////////////////////////////////////////////////////////////////////////
// Definition of law Lt
///////////////////////////////////////////////////////////////////////////////
#line 42 "willard-ast.ph"
inline Exp Lt(Exp a, Exp b)
{ return OP("<",list_1_(a,list_1_(b))); }

///////////////////////////////////////////////////////////////////////////////
// Definition of law Le
///////////////////////////////////////////////////////////////////////////////
#line 43 "willard-ast.ph"
inline Exp Le(Exp a, Exp b)
{ return OP("<=",list_1_(a,list_1_(b))); }

///////////////////////////////////////////////////////////////////////////////
// Definition of law In
///////////////////////////////////////////////////////////////////////////////
#line 44 "willard-ast.ph"
inline Exp In(Exp a, Exp b)
{ return OP("in",list_1_(a,list_1_(b))); }

///////////////////////////////////////////////////////////////////////////////
// Definition of law Union
///////////////////////////////////////////////////////////////////////////////
#line 45 "willard-ast.ph"
inline Exp Union(Exp a, Exp b)
{ return OP("union",list_1_(a,list_1_(b))); }

///////////////////////////////////////////////////////////////////////////////
// Definition of law Count
///////////////////////////////////////////////////////////////////////////////
#line 46 "willard-ast.ph"
inline Exp Count(Exp a)
{ return OP("#",list_1_(a)); }

///////////////////////////////////////////////////////////////////////////////
// Definition of law Nonempty
///////////////////////////////////////////////////////////////////////////////
#line 47 "willard-ast.ph"
inline Exp Nonempty(Exp a)
{ return OP("nonempty",list_1_(a)); }

#line 52 "willard-ast.ph"
#line 52 "willard-ast.ph"


#line 54 "willard-ast.ph"
#line 54 "willard-ast.ph"


#line 56 "willard-ast.ph"
#line 56 "willard-ast.ph"

#line 57 "willard-ast.ph"
#line 57 "willard-ast.ph"

#line 58 "willard-ast.ph"
#line 58 "willard-ast.ph"


// Avoid portability problems for now.

// refine Exp :: collectable;
// refine Literal :: collectable;
// refine List<T> :: collectable;

//
//  These are the pretty printing methods
//
extern PrettyOStream& operator << (PrettyOStream&, Exp);
extern PrettyOStream& operator << (PrettyOStream&, Ids);
extern PrettyOStream& operator << (PrettyOStream&, Exps);
extern PrettyOStream& operator << (PrettyOStream&, Literal);

#endif
#line 75 "willard-ast.ph"
/*
------------------------------- Statistics -------------------------------
Merge matching rules         = yes
Number of DFA nodes merged   = 0
Number of ifs generated      = 0
Number of switches generated = 0
Number of labels             = 0
Number of gotos              = 0
Adaptive matching            = disabled
Fast string matching         = disabled
Inline downcasts             = disabled
--------------------------------------------------------------------------
*/
