///////////////////////////////////////////////////////////////////////////////
//
//  This file contains the abstract syntax tree definitions for the
//  Prop language.  For simplicity, C++ statements are currently not
//  handled directly in the AST.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef abstract_syntax_tree_h
#define abstract_syntax_tree_h

#include "basics.ph"
#include "ir.h"

///////////////////////////////////////////////////////////////////////////////
//
//  Options to the pattern matching compiler.
//
///////////////////////////////////////////////////////////////////////////////

enum {
  MATCHnone            = 0,     // no option (select first matching rule)
  MATCHall             = 1<<0,  // select all matching rules
  MATCHwhile           = 1<<1,  // loop back
  MATCHnocheck         = 1<<2,  // no checking
  MATCHwithcost        = 1<<3,  // with cost minimization
  MATCHwithintcost     = 1<<4,  // with integer costs
  MATCHwithexpcost     = 1<<5,  // with expression costs
  MATCHwithtreecost    = 1<<6,  // use cumulative cost
  MATCHrefutable       = 1<<7,  // pattern is refutable
  MATCHscanner         = 1<<8,  // lexical scanner
  MATCHcaseinsensitive = 1<<9,  // insensitive case during string matching
  MATCHlexemepat       = 1<<10, // with lexeme pattern
  MATCHnotrace         = 1<<11, // no tracing
  MATCHunification     = 1<<12  // unification mode
};

///////////////////////////////////////////////////////////////////////////////
//
//  Forward type declarations.
//  These are defined in other places.
//
///////////////////////////////////////////////////////////////////////////////

datatype Ty                  // type expression
     and Pat                 // patterns
     and Cons                // constructor info
     and Literal             // literals
     and GramExp             // grammar expressions
     and FieldDef            // bitfield definition
     and FieldLaw            // bitfield law
     and Stmt                // statements
     and Def                 // definitions
     and Cost                // cost expression
     and ConstraintSet       // logical constraint rule set
     and GraphRewritingRule  // a graph rewriting rule
;

class ClassDefinition;
class RewriteIndexing;

///////////////////////////////////////////////////////////////////////////////
//
//  Information on a match rule.
//
///////////////////////////////////////////////////////////////////////////////

class MatchRuleInfo : public Loc
{
  MatchRuleInfo   (const MatchRuleInfo&);  // no copy constructor
  void operator = (const MatchRuleInfo&);  // no assignment

public:
  Bool used;           // is the rule being used?
  Ty   ty;             // type of pattern
  int  rule_number;    // rule number
  Bool negated;        // negation in inference?
  Bool rewriting;      // A rewriting pattern?
  Bool is_chain_rule;  // Chain rule?
  enum RewritingMode
  {
    BEFORE, PREORDER, POSTORDER, TOPDOWN, BOTTOMUP, LAST_REWRITING_MODE
  } mode;              // rewriting mode
  enum
  {
    NO_OPTIONS = 0, CUTREWRITE = 1, REPLACEMENT = 2, FAILREWRITE = 4
  };

  typedef int RewritingOption;
  RewritingOption option;

  MatchRuleInfo();
};

///////////////////////////////////////////////////////////////////////////////
//
//  Expressions.
//
///////////////////////////////////////////////////////////////////////////////

datatype Exp : public MEM =
  ////////////////////////////////////////////////////////////////////////////
  //
  //  Basic expressions.  These are mostly generated by the parser.
  //
  ////////////////////////////////////////////////////////////////////////////
    NOexp                       // no expression.
  | LITERALexp (Literal)        // literal expression.
  | IDexp      (Id)             // identifier
  | RELexp     int              // nth relation during inference
  | DOTexp     (Exp, Id)        // e . l
  | SELECTORexp(Exp, Cons, Ty)  // selector from a constructor
  | DEREFexp   (Exp)            // * e
  | ARROWexp   (Exp, Id)        // e -> l
  | INDEXexp   (Exp, Exp)       // e1 [ e2 ]
  | BINOPexp   (Id, Exp, Exp)   // e1 op e2
  | PREFIXexp  (Id, Exp)        // op e
  | POSTFIXexp (Id, Exp)        // e op
  | APPexp     (Exp, Exp)       // e1(e2)
  | ASSIGNexp  (Exp, Exp)       // e1 := e2
  | IFexp      (Exp, Exp, Exp)  // e1 ? e2 : e3
  | TUPLEexp   (List<Exp>)      // (e,...,e)
  | EXTUPLEexp (List<Exp>)      // .(e,...,e)
  | RECORDexp  (List<LabExp>)   // { x = e1, y = e2, ... z = en }
  | LISTexp    (Cons, Cons, List<Exp>, Exp) // #[1,2,3,4,5]
  | VECTORexp  (Cons, List<Exp>)            // [| 1, 2, 3, 4, 5 |]
  | CONSexp    (Cons, List<Exp>, Exp)       // cons(e)
  | CASTexp    (Ty,Exp)                     // casts
  | QUALexp    (Ty, Id)                     // qualified expression ty :: id

  ////////////////////////////////////////////////////////////////////////////
  //
  //  Extensions to deal with pattern matching, rewriting and inference.
  //  Most of these are generated internally.
  //
  ////////////////////////////////////////////////////////////////////////////
  | EQexp      (Ty, Exp, Exp)       // equality expression
  | UNIFYexp   (Ty, Exp, Exp)       // unification expression
  | LTexp      (Ty, Exp, Exp)       // less than expression
  | HASHexp    (Ty, Exp)            // hashing expression
  | THISCOSTexp()                   // current cost
  | COSTexp    (ChildNo)            // cost attribute of child
  | THISSYNexp (RuleNo,Ty,Bool)     // current synthesized attribue
  | SYNexp     (ChildNo, RuleNo,Ty,Bool) // synthesized attribute of child
  | SENDexp    (Id, List<Exp>)      // [| email sendTo: recipient |]

  ////////////////////////////////////////////////////////////////////////////
  //
  //  Extensions to deal with the SETL-like sublanguage.
  //
  ////////////////////////////////////////////////////////////////////////////
  | SETLexp    (SETLOp, Exps)        // SETL-like operator expression.
  | LISTCOMPexp { exp        : Exp,  // list comprehension
                  generators : List<Generator>,
                  guard      : Exp
                }
  | FORALLexp  (Id, Exp)             // universal quantifier
  | EXISTSexp  (Id, Exp)             // existential quantifier

  ////////////////////////////////////////////////////////////////////////////
  //
  //  Miscellaneous expressions.
  //
  ////////////////////////////////////////////////////////////////////////////
  | MARKEDexp  (Loc, Exp) // expressions marked with the location.
  public:
  {
     Ty ty;
  }

///////////////////////////////////////////////////////////////////////////////
//
//  SETL-like operators
//
///////////////////////////////////////////////////////////////////////////////

and SETLOp =
    ARBop         // extract arbitrary element
  | DOMop         // domain
  | RANop         // range
  | CARDop        // cardinality
  | WITHop        // with
  | WITHASSIGNop  // with :=
  | LESSop        // less
  | LESSASSIGNop  // less :=

///////////////////////////////////////////////////////////////////////////////
//
//  A generator expression:  pat | guard <- exp
//
///////////////////////////////////////////////////////////////////////////////

and Generator : public Loc =
  GENERATOR
  {
    pat   : Pat, // bindings
    guard : Exp, // guard expression, if any
    exp   : Exp  // a collection object
  }

///////////////////////////////////////////////////////////////////////////////
//
//  Pattern matching expressions.
//
///////////////////////////////////////////////////////////////////////////////

and MatchExp : public Loc = MATCHexp  (Exp, Id)

///////////////////////////////////////////////////////////////////////////////
//
//  Pattern matching rules.
//
///////////////////////////////////////////////////////////////////////////////

and MatchRule : public MatchRuleInfo =
  MATCHrule (Id, Pat, Exp, Cost, List<Decl>)
  // nonterminal -> pat | guard: action

///////////////////////////////////////////////////////////////////////////////
//
//  Prop declarations/specifications
//
///////////////////////////////////////////////////////////////////////////////

and Decl : public MEM =
    NOdecl
  | OPAQUEdecl          (const char *)

    // datatype and instantiation declarations
  | DATATYPEdecl        (DatatypeDefs, ViewDefs, LawDefs, TyDefs)
  | INSTANTIATEdecl     (Bool, Tys)

    // special class definition
  | CLASSDEFdecl        (ClassDefinition *)

    // inference rules declarations
  | INFERENCEdecl       (Id, InferenceRules)

    // rewriting rule declarations
  | REWRITEdecl         (Id, RewriteIndexings, MatchRules)
  | REWRITINGdecl       (Protocols, Exp, Exp, RewriteIndexings,
                         MatchRules, TyQual)
  | REPLACEMENTdecl     (Exp, MatchRuleInfo::RewritingMode)
  | CUTREWRITEdecl      (Exp, MatchRuleInfo::RewritingMode)
  | FAILREWRITEdecl     (MatchRuleInfo::RewritingMode)
  | INJECTdecl          { node_number : int,
                          direction   : EntryDirection
                        }
  | GOTOdecl            Id
  | SETSTATEdecl        int

    // constraint class and constraint declarations
  | CONSTRAINTdecl      (Id, ConstraintSet)

    // syntax class and grammar declarations
  | SYNTAXdecl          (Id, GramExp)
  | ATTRIBUTEGRAMMARdecl(Id, GramExp)

    // functions and pattern matching definitions
  | FUNdecl             (FunDefs)
  | MATCHdecl           (MatchExps, MatchRules, MatchOptions, Ty)

    // bitfield declarations
  | BITFIELDdecl        { name        : Id,
                          width       : int,
                          field_names : FieldDefs,
                          laws        : FieldLaws
                        }

    // SETL-style statements and definitions
  | SETLSTMTdecl        (Stmt)
  | SETLDEFdecl         (Def)

    // graphrewrite declarations
  | GRAPHREWRITEdecl       { name  : Id,
                             args  : LabTys,
                             rules : GraphRewritingRules
                           }

    // dataflow declarations
  | DATAFLOWdecl           { name : Id
                           }
    // misc expressions.
  | CLASSOFdecl         (Id)
  | TYPEEXPdecl         (Ty)
  | EXPdecl             { exp    : Exp,
                          prefix : const char * = 0,
                          suffix : const char * = 0
                        }

    // location marker
  | MARKEDdecl          (Loc, Decl)

///////////////////////////////////////////////////////////////////////////////
//
//  Direction of entry into the RETE network
//
///////////////////////////////////////////////////////////////////////////////

and EntryDirection = LEFTdirection | RIGHTdirection

///////////////////////////////////////////////////////////////////////////////
//
//  Protocol of a rewrite type defines the set inherited and synthesized
//  attributes for a rewrite type.
//
///////////////////////////////////////////////////////////////////////////////

and Protocol : public Loc = PROTOCOL { ty : Ty, inh : Ty, syn : Ty }

///////////////////////////////////////////////////////////////////////////////
//
//  Datatype definitions.
//
///////////////////////////////////////////////////////////////////////////////

and DatatypeDef : public Loc =
  DATATYPEdef (Id, TyVars, Inherits, TyQual, TermDefs, Decls)

///////////////////////////////////////////////////////////////////////////////
//
//  Definition of a constructor term.
//
///////////////////////////////////////////////////////////////////////////////

and     TermDef : public Loc =
  TERMdef
  {
    id             : Id,
    ty             : Ty,
    decls          : Decls        = #[],
    inherits       : Inherits     = #[],
    pat            : Pat          = NOpat,
    print_formats  : PrintFormats = #[],
    opt            : TyOpt        = OPTnone,
    qual           : TyQual       = QUALnone,
    view_predicate : Exp          = NOexp
  }

///////////////////////////////////////////////////////////////////////////////
//
//  Definition of a datatype view
//
///////////////////////////////////////////////////////////////////////////////

and ViewDef : public Loc = VIEWdef(Pat, Exp, List<LabExp>)

///////////////////////////////////////////////////////////////////////////////
//
//  Definition of a pattern law.
//
///////////////////////////////////////////////////////////////////////////////

and LawDef : public Loc =
  LAWdef
  {
    id     : Id,
    args   : Ids,
    guard  : Exp,
    pat    : Pat,
    invert : Bool,
    ty     : Ty = NOty
  }

///////////////////////////////////////////////////////////////////////////////
//
//  Type definitions.
//
///////////////////////////////////////////////////////////////////////////////

and TyDef : public Loc = TYdef( Id, TyVars, Ty, Bool)

///////////////////////////////////////////////////////////////////////////////
//
//  Function definitions.
//
///////////////////////////////////////////////////////////////////////////////

and FunDef : public Loc = FUNdef( QualId, Ty, Ty, MatchRules)

///////////////////////////////////////////////////////////////////////////////
//
//  A qualified name
//
///////////////////////////////////////////////////////////////////////////////

and QualId : public MEM = NESTEDid (Ty, QualId)
                        | SIMPLEid (Id)

///////////////////////////////////////////////////////////////////////////////
//
//  Inference rule
//
///////////////////////////////////////////////////////////////////////////////

and InferenceRule : public Loc =
      INFERENCErule( MatchRules, Exp, Conclusions)

and Conclusion : public Loc = ASSERTaction (Exp)
                            | RETRACTaction (Exp)
                            | STMTaction (Decls)

///////////////////////////////////////////////////////////////////////////////
//
//  Miscellaneous.
//
///////////////////////////////////////////////////////////////////////////////

where type MatchExps      = List<MatchExp>
and        MatchRules     = List<MatchRule>
and        Decls          = List<Decl>
and        DatatypeDefs   = List<DatatypeDef>
and        ViewDefs       = List<ViewDef>
and        LawDefs        = List<LawDef>
and        TyDefs         = List<TyDef>
and        TermDefs       = List<TermDef>
and        FunDefs        = List<FunDef>
and        Protocols      = List<Protocol>
and        LabExp         = { label : Id, exp : Exp }
and        LabMatchRule   = { id : QualId, rule : MatchRule, return_ty : Ty }
and        LabMatchRules  = { id : QualId, rules : MatchRules, return_ty : Ty }
and        Exps           = List<Exp>
and        LabExps        = List<LabExp>
and        InferenceRules = List<InferenceRule>
and        Conclusions    = List<Conclusion>
and        GraphRewritingRules = List<GraphRewritingRule>
and        FieldDefs      = List<FieldDef>
and        FieldLaws      = List<FieldLaw>
and        ChildNo        = int
and        RuleNo         = int
and        MatchOptions   = int
and        RewriteIndexings = List<RewriteIndexing *>
;

///////////////////////////////////////////////////////////////////////////////
//
//  AST manipulation methods.
//
///////////////////////////////////////////////////////////////////////////////

extern Exp component_exp(Exps, int);
extern Exp component_exp(Exps, Id);
extern Exp component_exp(LabExps, Id);

///////////////////////////////////////////////////////////////////////////////
//
//  Pretty printing methods.
//
///////////////////////////////////////////////////////////////////////////////

extern std::ostream& operator << (std::ostream&, Exp);
extern std::ostream& operator << (std::ostream&, List<Exp>);
extern std::ostream& operator << (std::ostream&, LabExp);
extern std::ostream& operator << (std::ostream&, List<LabExp>);
extern std::ostream& operator << (std::ostream&, Cost);
extern std::ostream& operator << (std::ostream&, MatchRule);
extern std::ostream& operator << (std::ostream&, QualId);

#endif
